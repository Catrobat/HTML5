<html>
<head>
<title>broadcastManager.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { }
.s2 { color: rgb(0,128,0); font-weight: bold; }
.s3 { color: rgb(0,0,128); font-weight: bold; }
.s4 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
.s5 { color: rgb(0,0,255); }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
broadcastManager.js</FONT>
</center></TD></TR></TABLE>
<pre>

<span class="s0">/// &lt;reference path=&quot;../../../smartJs/sj.js&quot; /&gt;</span><span class="s1"> 
</span><span class="s0">/// &lt;reference path=&quot;../../../smartJs/sj-event.js&quot; /&gt;</span><span class="s1"> 
</span><span class="s0">/// &lt;reference path=&quot;../core.js&quot; /&gt;</span><span class="s1"> 
</span><span class="s2">'use strict'</span><span class="s1">; 
 
PocketCode.BroadcastManager = (</span><span class="s3">function </span><span class="s1">() { 
 
    </span><span class="s0">//ctr: broadcast = [{id: &quot;s12&quot;, name:&quot;asd&quot;}, {...}]</span><span class="s1"> 
    </span><span class="s0">/** 
     * 
     * </span><span class="s4">@param </span><span class="s0">broadcasts 
     * </span><span class="s4">@constructor</span><span class="s0"> 
     */</span><span class="s1"> 
    </span><span class="s3">function </span><span class="s1">BroadcastManager(broadcasts) { 
        </span><span class="s3">this</span><span class="s1">.init(broadcasts); 
    } 
 
    </span><span class="s0">//methods</span><span class="s1"> 
 
    </span><span class="s0">/** 
     * 
     */</span><span class="s1"> 
    BroadcastManager.prototype.merge({ 
        </span><span class="s0">/** 
         * 
         * </span><span class="s4">@param </span><span class="s0">broadcasts 
         */</span><span class="s1"> 
        init: </span><span class="s3">function</span><span class="s1">(broadcasts) { 
            </span><span class="s3">this</span><span class="s1">._pendingBW = {}; 
 
            </span><span class="s3">this</span><span class="s1">._subscriptions = {}; 
            </span><span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">, l = broadcasts.length; i &lt; l; i++) { 
                </span><span class="s3">this</span><span class="s1">._subscriptions[broadcasts[i].id] = []; 
            } 
        }, 
        </span><span class="s0">/** 
         * 
         * </span><span class="s4">@param </span><span class="s0">bcId 
         * </span><span class="s4">@param </span><span class="s0">listener 
         */</span><span class="s1"> 
        subscribe: </span><span class="s3">function </span><span class="s1">(bcId, listener) { 
            </span><span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">bcId !== </span><span class="s2">'string'</span><span class="s1">) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: broadcast id, expected type: string'</span><span class="s1">); 
            </span><span class="s3">if </span><span class="s1">(!(listener </span><span class="s3">instanceof </span><span class="s1">SmartJs.Event.EventListener)) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: subscriber listener, expected type: SmartJs.Event.EventListener'</span><span class="s1">); 
 
            </span><span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">._subscriptions[bcId]) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: invalid (unknown) broadcast id'</span><span class="s1">); 
            </span><span class="s3">this</span><span class="s1">._subscriptions[bcId].push(listener); 
        }, 
        </span><span class="s0">/** 
         * 
         * </span><span class="s4">@param </span><span class="s0">bcId 
         * </span><span class="s4">@param </span><span class="s0">pubListener 
         * </span><span class="s4">@param </span><span class="s0">threadId 
         */</span><span class="s1"> 
        publish: </span><span class="s3">function </span><span class="s1">(bcId, pubListener, threadId) {  </span><span class="s0">//listener type of SmartJs.Event.EventListener</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">bcId !== </span><span class="s2">'string' </span><span class="s1">|| !</span><span class="s3">this</span><span class="s1">._subscriptions[bcId]) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: broadcast id not found'</span><span class="s1">); 
            </span><span class="s3">if </span><span class="s1">(pubListener &amp;&amp; !(pubListener </span><span class="s3">instanceof </span><span class="s1">SmartJs.Event.EventListener)) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: event listener'</span><span class="s1">); 
            </span><span class="s3">if </span><span class="s1">(pubListener &amp;&amp; !threadId) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: threadId: a thread id is required for broadcastWait calls'</span><span class="s1">); 
 
            </span><span class="s3">if </span><span class="s1">(pubListener) 
                </span><span class="s3">this</span><span class="s1">._handleBroadcastWait(bcId, pubListener, threadId); 
            </span><span class="s3">else </span><span class="s1">{ 
                </span><span class="s0">//handle default broadcast</span><span class="s1"> 
                </span><span class="s3">var </span><span class="s1">subs = </span><span class="s3">this</span><span class="s1">._subscriptions[bcId]; 
                </span><span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">, l = subs.length; i &lt; l; i++) { 
                    </span><span class="s0">//this._subscriptions[bcId].execute();    //each brick supports .execute()</span><span class="s1"> 
                    </span><span class="s3">var </span><span class="s1">subListener = subs[i]; 
                    subListener.handler.call(subListener.scope); 
                } 
            } 
        }, 
        </span><span class="s0">/** 
         * 
         * </span><span class="s4">@param </span><span class="s0">brId 
         * </span><span class="s4">@param </span><span class="s0">pubListener 
         * </span><span class="s4">@param </span><span class="s0">callId 
         * </span><span class="s4">@private</span><span class="s0"> 
         */</span><span class="s1"> 
        _handleBroadcastWait: </span><span class="s3">function </span><span class="s1">(brId, pubListener, callId) { 
            </span><span class="s3">if </span><span class="s1">(!(pubListener </span><span class="s3">instanceof </span><span class="s1">SmartJs.Event.EventListener)) 
                </span><span class="s3">throw new </span><span class="s1">Error(</span><span class="s2">'invalid argument: publisher Listener, expected type: SmartJs.Event.EventListener'</span><span class="s1">); 
 
            </span><span class="s3">var </span><span class="s1">subs = </span><span class="s3">this</span><span class="s1">._subscriptions[brId]; 
            </span><span class="s3">var </span><span class="s1">subsCount = subs.length;    </span><span class="s0">//how many listeners</span><span class="s1"> 
 
            </span><span class="s3">if </span><span class="s1">(subsCount &gt; </span><span class="s5">0</span><span class="s1">) { 
                </span><span class="s3">var </span><span class="s1">threadId = SmartJs._getId();            </span><span class="s0">//each br wait call has its own unique id</span><span class="s1"> 
                </span><span class="s3">this</span><span class="s1">._pendingBW[threadId] = { callId: callId, broadcastId: brId, counter: subsCount, listener: pubListener, loopDelay: </span><span class="s3">false </span><span class="s1">}; 
                </span><span class="s0">//notify subscribers</span><span class="s1"> 
                </span><span class="s0">//var subsCount = this._subscriptions[brId];</span><span class="s1"> 
                </span><span class="s3">for </span><span class="s1">(</span><span class="s3">var </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; subsCount; i++) { 
                    </span><span class="s3">var </span><span class="s1">subListener = subs[i];  </span><span class="s0">//listening brick</span><span class="s1"> 
                    subListener.handler.call(subListener.scope, { id: threadId, listener: </span><span class="s3">new </span><span class="s1">SmartJs.Event.EventListener(</span><span class="s3">this</span><span class="s1">._brickExecutedHandler, </span><span class="s3">this</span><span class="s1">) }); 
                    </span><span class="s0">//add event to brick to get return value</span><span class="s1"> 
                    </span><span class="s0">//brick.execute(new SmartJs.Event.EventListener(_brickExecutedHandler, this), threadId);</span><span class="s1"> 
                } 
            } 
            </span><span class="s3">else    </span><span class="s0">//no subscribers</span><span class="s1"> 
                </span><span class="s3">this</span><span class="s1">._notifyPublisher(pubListener, threadId); 
        }, 
        </span><span class="s0">/** 
         * 
         * </span><span class="s4">@param </span><span class="s0">e 
         * </span><span class="s4">@private</span><span class="s0"> 
         */</span><span class="s1"> 
        _brickExecutedHandler: </span><span class="s3">function </span><span class="s1">(e) {   </span><span class="s0">//id, loopDelay) {</span><span class="s1"> 
            </span><span class="s3">var </span><span class="s1">pendingBW = </span><span class="s3">this</span><span class="s1">._pendingBW[e.id]; 
            </span><span class="s0">//var counter = pendingBW.counter;</span><span class="s1"> 
            </span><span class="s3">if </span><span class="s1">(pendingBW.counter === </span><span class="s5">1</span><span class="s1">) {    </span><span class="s0">//last</span><span class="s1"> 
                </span><span class="s3">var </span><span class="s1">callId = pendingBW.callId; 
                </span><span class="s3">var </span><span class="s1">pubListener = pendingBW.listener; 
                </span><span class="s3">var </span><span class="s1">loopDelay = pendingBW.loopDelay || e.loopDelay; 
                </span><span class="s3">delete this</span><span class="s1">._pendingBW[e.id];    </span><span class="s0">//remove from pending broadcasts</span><span class="s1"> 
                </span><span class="s3">this</span><span class="s1">._notifyPublisher(pubListener, callId, loopDelay); 
            } 
            </span><span class="s3">else </span><span class="s1">{ </span><span class="s0">// termination?</span><span class="s1"> 
                pendingBW.counter--; 
                pendingBW.loopDelay = pendingBW.loopDelay || e.loopDelay; 
            } 
        }, 
        </span><span class="s0">/** 
         * 
         * </span><span class="s4">@param </span><span class="s0">pubListener 
         * </span><span class="s4">@param </span><span class="s0">threadId 
         * </span><span class="s4">@param </span><span class="s0">loopDelay 
         * </span><span class="s4">@private</span><span class="s0"> 
         */</span><span class="s1"> 
        _notifyPublisher: </span><span class="s3">function </span><span class="s1">(pubListener, threadId, loopDelay) { 
            pubListener.handler.call(pubListener.scope, { id: threadId, loopDelay: loopDelay }); 
        }, 
    }); 
 
    </span><span class="s3">return </span><span class="s1">BroadcastManager; 
})(); 
 
</span></pre>
</body>
</html>